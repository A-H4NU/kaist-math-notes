\documentclass[../introduction_to_set_theory.tex]{subfiles}
\begin{document}

\section{Introduction to Natural Numbers}

\nt{
    We cannot prove an existence of an `infinite' set (in the classical sense) or discuss infinity
    only from \Crefrange{ax:existence}{ax:powerSet}.
}

\dfn[successor]{Successor}{
    The \textit{successor} of a set \(x\) is the set \(S(x) = x \cup \{x\}\).
}

\notat[nPlusOne]{\(\boldsymbol{n+1}\)}{
    We write \(n + 1\) to denote \(S(n)\).
    There is no implication regarding the classic ``addition'' in this notation.
}

\notat{Natural Numbers}{
    \begin{itemize}[nolistsep, leftmargin=*]
        \ii \(0 = \OO\)
        \ii \(1 = \{\OO\} = S(0) = 0 + 1\)
        \ii \(2 = \{\OO, \{\OO\}\} = S(1) = 1 + 1\)
        \ii \(\cdots\)
    \end{itemize}
}

\dfn[inductiveSet]{Inductive Set}{
    A set \(I\) is called \textit{inductive} if
    \[
        0 \in I \land \fall n \in I,\: (n + 1) \in I.
    \]
}

\axiom[infinity]{Axiom of Infinity}{
    \noindent
    An inductive set exists.
}

\dfn[]{Set of All Natural Numbers}{
    The \textit{set of all natural numbers} is the set
    \[
        \NN \triangleq \{\,x \mid x \in I \text{ for all inductive set }I\,\}.
    \]
}

\nt{
    \nameref{ax:infinity} guarantees the existence of \(\NN\).
    For, if \(A\) is any inductive set, then
    \(\NN = \{\,x \in A \mid x \in I \text{ for all inductive set }I\,\}\).
}

\mlemma[NisInductive]{}{
    \(\NN\) is inductive. In addition, if \(I\) is an inductive set, then \(\NN \subseteq I\).
}
\pf{Proof}{
    Since \(0 \in I\) for all inductive set, \(0 \in \NN\).
    If \(n \in \NN\), then \(n \in I\) for all inductive set,
    and thus \((n + 1) \in I\) for all inductive set.
    Therefore, \((n + 1) \in \NN\). Hence, \(\NN\) is inductive.

    \(\NN \subseteq I\) directly follows from the definition of \(\NN\).
}

\dfn[]{}{
    The relation \(<\) on \(\NN\) is defined by: \(m < n\) if and only if \(m \in n\).
}

\notat{}{
    Although we did not prove \(<\) is a strict ordering of \(\NN\),
    we shall use \(\le\) to denote the relation on \(\NN\):
    \[
        \mathord{\le} \triangleq \mathord{<} \cup \mrm{Id}_{\NN}
    \]
}

\subsection*{Selected Problems}

\exer[3.1.1]{}{
    \begin{enumerate}[nolistsep, label=(\roman*), leftmargin=*]
        \ii \(\fall x,\: x \subseteq S(x)\)
        \ii \(\fall x,\: \lnot(\exs z,\: x \subsetneq z \subsetneq S(x))\)
    \end{enumerate}
}
\mclm{Proof}{\hfill
\begin{enumerate}[nolistsep, label=(\roman*)]
    \ii
    \(x \subseteq x \subseteq x \cup \{x\} = S(x)\)

    \ii
    Take any \(z\) such that such that \(x \subseteq z \subseteq S(x) = x \cup \{x\}\).
    If \(z \subseteq x\), then we have \(z = x\).
    If \(z \not\subseteq x\), then there exists \(y\) such that
    \(y \in z\) and \(y \notin x\).
    However, \(y \in x \cup \{x\}\), and thus \(y = x\).
    Therefore, \(S(x) \subseteq z\); \(z = S(x)\).
    In conclusion, any \(z\) such that \(x \subseteq z \subseteq S(x)\)
    must satisfy \(z = x\) or \(z = S(x)\).
    \qed
\end{enumerate}
}

\section{Properties of Natural Numbers}

\thm[induction]{The Induction Principle}{
    Let \(\mbf{P}(x)\) be a property (possibly with parameters).
    \[
        \mbf{P}(0) \land \fall n \in \NN,\: (\mbf{P}(n) \implies \mbf{P}(n+1))
        \implies \fall n \in \NN,\: \mbf{P}(n)
    \]
}
\pf{Proof}{
    The premise simply says that \(A = \{\,n \in \NN \mid \mbf{P}(n)\,\}\) is inductive.
    Therefore, \(\NN \subseteq A\) follows.
}

\mlemma[basicLess]{}{
    \begin{enumerate}[nolistsep, label=(\roman*), ref=\protect{\Cref{lem:basicLess} (\roman*)}]
        \ii \label{itm:basicLess.i}\(\fall n \in \NN,\: 0 \le n\)
        \ii \label{itm:basicLess.ii}\(\fall k, n \in \NN,\: (k < n + 1 \iff k < n \lor k = n)\)
    \end{enumerate}
}
\mclm{Proof}{\hfill
\begin{enumerate}[nolistsep, label=(\roman*), listparindent=\parindent]
    \ii
    Let \(\mbf{P}(x)\) be the property ``\(0 \le x\).''
    \(\mbf{P}(0)\), i.e., \(0 \le 0\), holds since \(0 = 0\).

    Now, assume \(n \in \NN\) and \(\mbf{P}(n)\).
    If \(n = 0\), then we have \(0 \in S(0) = n + 1\) by definition (\Cref{dfn:successor}).
    If \(0 < n\), then \(0 \in n\), and thus \(0 \in n \cup \{n\} = S(n)\).
    Therefore, by \nameref{th:induction}, the result follows.
    
    \ii
    Note that \(k \in n \cup \{n\}\) if and only if \(k \in n\) or \(k = n\).
    \qed
\end{enumerate}
}

\thm[NisLinearlyOrdered]{\((N, \le)\) is Linearly Ordered}{
    \((N, \le)\) is a linearly ordered set.
}
\pf{Proof}{
    We first need to prove that \((\NN, \le)\) is an ordered set.
    \clm[lessIsTransitive]{
        \(<\) is transitive in \(\NN\).
    }{
        Let \(\mbf{P}(x)\) be the property ``\(\fall k, m \in \NN,\: (k < m \land m < x \implies k < x)\).''
        \(\mbf{P}(0)\) is true because there is no \(m \in \NN\) such that \(m \in 0 = \OO\).

        Now assume \(n \in \NN\) and \(\mbf{P}(n)\).
        Now, let \(k, m \in \NN\) and \(k < m\) and \(m < n + 1\).
        By \ref{itm:basicLess.ii}, \(m < n\) or \(m = n\).
        \begin{itemize}[nolistsep]
            \ii 
            If \(m < n\), then we have \(k < n\) as \(\mbf{P}(n)\) holds,
            \ii
            If \(m = n\), then we immediately have \(k < n\).
        \end{itemize}
        In both cases, we have \(k < n\); thus \(k < n + 1\) by \ref{itm:basicLess.ii}.
        Therefore, the result follows from \nameref{th:induction}.
        \qed
    }

    \clm[lessIsAsymmetric]{
        \(<\) is asymmetric in \(\NN\).
    }{
        Let \(\mbf{P}(x)\) be the property ``\(\lnot(x < x)\).''
        \(\mbf{P}(0)\) evidently holds since \(\OO \notin \OO\).

        Now, assume \(n \in \NN\) and \(\mbf{P}(n)\).
        Suppose \((n + 1) < (n + 1)\) for the sake of contradiction.
        By \ref{itm:basicLess.ii}, we have \((n + 1) = n\) or \((n + 1) < n\).
        In both cases, we have \(n < n\) by \(n < (n + 1)\) (from \ref{itm:basicLess.ii}) and
        \Cref{clm:lessIsTransitive}, which contradicts \(\mbf{P}(n)\).
        Therefore, \(\mbf{P}(n+1)\) holds.
        The result follows from \nameref{th:induction}. \qed
    }
    Hence, \((\NN, \le)\) is an ordered set by \Cref{clm:lessIsTransitive,clm:lessIsAsymmetric,th:partialAndStrictAreSame}.
    We are left to prove that \(\le\) is a linear ordering of \(\NN\).

    \clm[nPlusOne]{
        \(\fall n, m \in \NN,\: n < m \implies (n + 1) \le m\)
    }{
        Let \(\mbf{P}(x)\) be the property ``\(\fall n \in \NN, (n < x \implies n + 1 \le x)\).''
        \(\mbf{P}(0)\) holds since there is no \(n \in \NN\) such that \(n < 0\).

        Now, assume \(m \in \NN\) and \(\mbf{P}(m)\).
        Take any \(n \in \NN\) such that \(n < (m + 1)\).
        Then, by \Cref{lem:basicLess}, we have \(n = m\) or \(n < m\).
        If \(n =  m\), then we have \((n + 1) = (m + 1)\), which implies \((n + 1) \le (m + 1)\).
        If \(n < m\), then \((n + 1) \le m < (m + 1)\).
        Therefore, the result follows from \nameref{th:induction}. \qed
    }

    \clm[lessIsLinear]{
        \(<\) is a linear ordering of \(\NN\).
    }{
        Let \(\mbf{P}(x)\) be the property ``\(\fall m \in \NN,\: m = x \lor m < x \lor x < m\).''
        \(\mbf{P}(0)\) is essentially \ref{itm:basicLess.i}.

        Assume \(n \in \NN\) and \(\mbf{P}(n)\).
        Take any \(m \in \NN\).
        If \(m < n\) or \(m = n\), we have \(m < (n+1)\) by \ref{itm:basicLess.ii}.
        If \(n < m\), by \Cref{clm:nPlusOne}, we have \((n + 1) \le m\).
        Hence, \(\mbf{P}(n+1)\) holds.
        Therefore, the result follows from \nameref{th:induction}. \qed
    }
}

\notat{}{
    We may write ``\(\fall k < n, \mbf{P}(k)\)'' instead of ``\(\fall k \in \NN,\: (k < n \implies \mbf{P}(k))\)''
    or ``\(\exs k < n, \mbf{P}(k)\)'' instead of ``\(\exs k \in \NN,\: k < n \land \mbf{P}(k)\)''
    when no confusion may arise.
    We may similarly write \((\fall/\exs) k (\mathord{\le}/\mathord{>}/\mathord{\ge}) n\), \(\mbf{P}(k)\).
}

\thm[strongInduction]{The Strong Induction Principle}{
    Let \(\mbf{P}(x)\) be a property (possibly with parameters).
    If, for all \(n \in \NN\), \(\mbf{P}(k)\) holds for all \(k < n\),
    then \(\mbf{P}(n)\) holds for all \(n \in \NN\).
    \[
        \fall n \in \NN,\: [\fall k < n,\: \implies \mbf{P}(k) \implies \mbf{P}(n)] \implies \fall n \in \NN,\: \mbf{P}(n)
    \]
}
\pf{Proof}{
    Assume the premise (\(\fall n \in \NN,\: [\fall k < n,\: \implies \mbf{P}(k) \implies \mbf{P}(n)]\)).
    Let \(\mbf{Q}(n)\) be the property ``\(\fall k < n, \mbf{P}(k)\).''
    \(\mbf{Q}(0)\) holds since there is no \(k < 0\).

    Now, assume \(n \in \NN\) and \(\mbf{Q}(n)\).
    Then, by the premise, we have \(\mbf{P}(n)\).
    \ref{itm:basicLess.ii} enables us to say that \(\fall k \in \NN,\: (k < n + 1 \implies P(k))\).
    Therefore, \(\fall n \in \NN,\: \mbf{Q}(n)\) holds by \nameref{th:induction}.

    Take any \(k \in \NN\). Then, we have \(k < k + 1\) and thus \(\mbf{P}(k)\) holds
    by \(\mbf{Q}(k+1)\).
}

\dfn[wellOrdering]{Well-Ordering}{
    A linear ordering \(\preceq\) of a set \(A\) is a \textit{well-ordering}
    if every nonempty subset of \(A\) has a least element.
    Then, the ordered set \((A, \preceq)\) is called a \textit{well-ordered set}.
}

\thm[NisWellOrdered]{\(\NN\) is Well-Ordered}{
    \((\NN, \le)\) is a well-ordered set.
}
\pf{Proof}{
    Let \(X \subseteq \NN\) has no least element.
    For each \(n \in \NN\), if \(\fall k < n,\: k \in \NN \setminus X\), we must have \(n \in \NN \setminus X\)
    since otherwise \(n = \min X\).
    Then, by \nameref{th:strongInduction}, \(\fall n \in \NN,\: n \in \NN \setminus X\),
    i.e., \(X = \OO\).
}

\thm[hasUpperBoundThenMaxExists]{}{
    Let \(\OO \subsetneq X \subseteq \NN\).
    If \(X\) has an upper bound in the ordering \(\le\), then \(X\) has a greatest element.
}
\pf{Proof}{
    Let \(Y \triangleq \{\,k \in \NN \mid k \text{ is an upper bound of }X\,\}\).
    The assumption says that \(Y \neq \OO\).
    By \nameref{th:NisWellOrdered}, \(n \triangleq \min Y = \sup X\) exists.

    Suppose \(n \notin X\) for the sake of contradiction.
    Then, \(\fall m \in X,\: m < n\), which implies \(n \neq 0\) as \(X \neq \OO\).
    Therefore, \(n = k + 1\) for some \(k \in \NN\) by \Cref{exer:3.2.4};
    and thus \(\fall m \in X,\: m \le k\) by \ref{itm:basicLess.ii}.
    Then, \(k\) is an upper bound of \(A\) and \(k < n\), which is a contradiction to \(n = \sup X\).
    Therefore, \(n \in X\), and hence \(n = \max X\) by \Cref{th:basicInfimum}.
}

\subsection*{Selected Problems}

\setexernumber{1}

\exer[3.2.2]{}{
    \(\fall m, n \in \NN,\: (m < n \implies m + 1 < n + 1)\).
    Hence, \(S \colon \NN \to \NN\) where \(n \mapsto n+1\) defines a one-to-one function on \(\NN\).
}
\pf{Proof}{
    By \Cref{clm:nPlusOne} in the proof of \nameref{th:NisLinearlyOrdered},
    we have \(m+1 \le n\). Together with \(n < n + 1\), we have
    \(m + 1 < n + 1\).

    Now, take any \(m, n \in \NN\) with \(m \neq n\).
    Then, by \nameref{th:NisLinearlyOrdered}, we have \(m < n\) or \(n < m\),
    i.e., \(S(m) < S(n)\) or \(S(n) < S(m)\).
    In both cases, \(S(m) \neq S(n)\).
    Therefore, \(S\) is one-to-one.
}

\exer[3.2.3]{}{
    There exists \(X \subsetneq \NN\) and \(f \colon \NN \to X\)
    such that \(f\) is injective.
}
\pf{Proof}{
    Let \(S \colon \NN \to \NN\) where \(n \mapsto n + 1\).
    Then, \(S\) is injective by \Cref{exer:3.2.2}.
    Since there exists no \(n \in \NN\) such that \(n \cup \{n\} = \OO\),
    \(0 \notin \ran S\); \(\ran S \subsetneq \NN\).
    Therefore, \(S \colon \NN \to \ran S\) is the function we are looking for.
}

\exer[3.2.4]{}{
    \(\fall n \in \NN \setminus \{0\},\: \exs! k \in \NN,\: n = k + 1\)
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property ``\(x = 0 \lor \exs! k \in \NN,\: x = k + 1\).''
    \(\mbf{P}(0)\) holds by definition.

    Now, assume \(\mbf{P}(n)\) where \(n \in \NN\).
    There exists \(k \in \NN\) such that \(n + 1 = k + 1\), namely, \(k = n\).
    If \(k'\) is another natural number such that \(n + 1 = k' + 1\),
    then by \Cref{exer:3.2.2}, we have \(k = k'\).
    Hence, \(\mbf{P}(n+1)\) holds.
    The result follows from \nameref{th:induction}.
}

\setexernumber{5}

\exer[3.2.6]{}{
    \(\fall n \in \NN,\: n = \{\,m \in \NN \mid m < n\,\}\)
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property ``\(x = \{\,m \in \NN \mid m < x\,\}\).''
    We have \(\mbf{P}(0)\) since there exists no \(m \in \NN\) with \(m < 0\).

    Now, assume \(\mbf{P}(n)\) where \(n \in \NN\).
    Then, \(n + 1 = \{\,m \in \NN \mid m < n\,\} \cup \{n\}\).
    By \ref{itm:basicLess.ii}, \(m < n + 1\) if and only if \(m < n\) or \(m = n\).
    Therefore,
    \(\{\,m \in \NN \mid m < n\,\} \cup \{n\} = \{\,m \in \NN \mid m < n \lor m = n\,\}
    = \{\,m \in \NN \mid m < n + 1\,\}\); \(\mbf{P}(n+1)\) holds.
    The result follows from \nameref{th:induction}.
}

\setexernumber{7}

\exer[3.2.7]{}{
    There is no function \(f \colon \NN \to \NN\) such that
    \(\fall n \in \NN,\: f(n + 1) < f(n)\).
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property ``there is no function \(f \colon \NN \to \NN\) such that
    \(f(0) = x\) and \(\fall n \in \NN,\: f(n + 1) < f(n)\).''

    For the sake of induction, assume \(\fall k < n,\: P(k)\) where \(n \in \NN\).
    Suppose there exists \(f \colon \NN \to \NN\) such that
    \(f(0) = n\) and \(\fall k \in \NN,\: f(k + 1) < f(k)\).
    Now, define \(g \colon \NN \to \NN\) by \(g(k) = f(k + 1)\).
    Then, \(g(0) = f(1) < n\) and \(\fall k \in \NN,\: g(k + 1) = f((k + 1) + 1) < f(k + 1) = g(k)\).
    However, by \(\mbf{P}(g(0))\), such \(g\) cannot exist;
    by contradiction, \(\mbf{P}(n)\) holds.
    Hence, \(\fall m \in \NN,\: \mbf{P}(m)\) by \nameref{th:strongInduction}.

    Finally, suppose there exists \(f \colon \NN \to \NN\) such that \(\fall n \in \NN,\: f(n + 1) < f(n)\).
    Then, by \(\mbf{P}(f(0))\), such \(f\) may not exist.
}

\setexernumber{10}

\exer[3.2.11]{}{
    Let \(\mbf{P}(x)\) be a property and let \(k \in \NN\).
    \[
        \mbf{P}(k) \land \fall n \ge k,\: (\mbf{P}(n) \implies \mbf{P}(n+1))
        \implies \fall n \ge k,\: \mbf{P}(n)
    \]
}
\pf{Proof}{
    Let \(\mbf{Q}(x)\) be the property ``\(x < k \lor \mbf{P}(x)\).''
    If \(k = 0\), then \(\mbf{P}(0)\) holds. If \(k > 0\), then \(0 < k\) holds.
    Hence, in both cases, \(\mbf{Q}(0)\) holds.

    Now assume \(\mbf{Q}(n)\) holds where \(n \in \NN\).
    Then, by \nameref{th:NisLinearlyOrdered}, we have \(n + 1 < k\), \(n + 1 = k\), or \(n + 1 > k\).
    If \(n + 1 < k\) or \(n + 1 = k\), we immediately have \(\mbf{Q}(n + 1)\).
    If \(n + 1 > k\), we have \(n \ge k\) by \ref{itm:basicLess.ii}.
    Therefore, \(\mbf{P}(n)\) holds, and thus \(\mbf{P}(n+1)\) holds by assumption.
    Hence, \(\mbf{Q}(n+1)\).
    By \nameref{th:induction}, \(\fall n \in \NN,\: n < k \lor \mbf{P}(n)\).
    In other words, \(\fall n \ge k,\: \mbf{P}(n)\).
}

\exer[3.2.12]{The Finite Induction Principle}{
    Let \(\mbf{P}(x)\) be a property and let \(k \in \NN\).
    \[
        \mbf{P}(0) \land \fall n < k,\: (\mbf{P}(n) \implies \mbf{P}(n+1))
        \implies \fall n \le k,\: \mbf{P}(n)
    \]
}
\pf{Proof}{
    Let \(\mbf{Q}(x)\) be the property ``\(x > k \lor \mbf{P}(x)\).''
    \(\mbf{Q}(0)\) holds as \(\mbf{P}(0)\).

    Now, assume \(\mbf{Q}(n)\) holds where \(n \in \NN\).
    Then, by \nameref{th:NisLinearlyOrdered}, we have \(n + 1 \le k\) or \(n + 1 > k\).
    If \(n + 1 > k\), then we immediately have \(\mbf{Q}(n + 1)\).
    If \(n + 1 \le k\), by \Cref{lem:basicLess}, \(n + 1 < k + 1\).
    By \Cref{exer:3.2.2} and \nameref{th:NisLinearlyOrdered}, we must have \(n < k\).
    Hence, \(\mbf{P}(n)\) holds, and therefore \(\mbf{P}(n+1)\) holds by the assumption.
    By \nameref{th:induction}, \(\fall n \in \NN,\: n > k \lor \mbf{P}(n)\).
    In other words, \(\fall n \le k,\: \mbf{P}(n)\).
}

\exer[3.2.13]{The Double Induction Principle}{
    Let \(\mbf{P}(x, y)\) be a property.
    \begin{gather}
        \fall m, n \in \NN,\: [\fall k, \ell \in \NN,\: (k < m \lor k = m \land \ell < n \implies \mbf{P}(k, \ell)) \implies \mbf{P}(m, n)]\tag{\(\ast\)}\label{eq:doubleInduction}\\
        \implies \fall m, n \in \NN,\: \mbf{P}(m, n)\nonumber
    \end{gather}
}
\pf{Proof}{
    Let \(\mbf{Q}(x)\) be the property ``\(\fall n \in \NN,\: \mbf{P}(x, n)\).''

    Now, assume \(\fall k < m,\: \mbf{Q}(k)\) where \(m \in \NN\).
    For the sake of induction, assume again that \(\fall \ell < n,\: \mbf{P}(m, \ell)\) where \(n \in \NN\).
    Now, we have \(\mbf{P}(k, \ell)\) for all \(k, \ell \in \NN\) such that
    \(k < m\) or \(k = m\) and \(\ell < n\).
    Hence, by \eqref{eq:doubleInduction}, \(\mbf{P}(m, n)\).
    By \nameref{th:strongInduction}, we have \(\fall n \in \NN,\: \mbf{P}(m, n)\).
    In other words, \(\mbf{Q}(m)\).
    Again by \nameref{th:strongInduction}, we have \(\fall m \in \NN,\: \mbf{Q}(m)\),
    that is to say \(\fall m, n \in \NN,\: \mbf{P}(m, n)\).
}

\section{The Recursion Theorem}

\dfn[sequence]{Sequence}{
    \begin{itemize}[nolistsep, leftmargin=*]
        \ii 
        A \textit{sequence} is a function whose domain is a natural number or \(\NN\).

        \ii
        A sequence whose domain is a natural number \(n\) is called a
        \textit{finite sequence of length \(n\)} and is denoted
        \[
            \lang\: a_i \mid i < n \:\rang \quad\text{or}\quad
            \lang\: a_i \mid i = 0, 1, \cdots, n - 1 \:\rang \quad\text{or}\quad
            \lang\: a_0, a_1, \cdots, a_{n-1} \:\rang.
        \]
        In particular, \(\lang\rang = \OO\)---the \textit{empty sequence}---is the unique sequence of length \(0\).
        \[
            \textstyle\Seq(A) \triangleq \bigcup_{n \in \NN} A^n
        \]
        denote the set of all finite sequence of elements of \(A\).

        \ii
        A sequence whose domain is \(\NN\) is called a \textit{infinite sequence}
        and is denoted
        \[
            \lang\: a_i \mid i \in \NN \:\rang \quad\text{or}\quad
            \lang\: a_i \mid i = 0, 1, 2, \cdots \:\rang \quad\text{or}\quad
            \lang a_i \rang_{i=0}^{\infty}.
        \]
        Infinite sequences of elements of \(A\) are members of \(A^{\NN}\).
        We also use the notation \(\{\,a_i \mid i \in \NN\,\}\) or \(\{a_i\}_{i=0}^\infty\), etc.,
        for the range of the sequence \(\lang a_i \mid i \in \NN \rang\).
    \end{itemize}
}

\nt{
\begin{itemize}[nolistsep, leftmargin=*]
    \ii
    A natural number \(n \in \NN\) is the set of all natural numbers less than \(n\).
    See \Cref{exer:3.2.6}.
    \ii 
    Since \(A^n \in \mcal P(\NN \times A)\) for each \(n \in \NN\),
    \(\mcal A = \{\,w \mid \exs n \in \NN,\:w = A^n\,\}\) exists,
    and thus \(\Seq(A) = \bigcup \mcal A\) exists.
\end{itemize}
}

\thm[recursion]{The Recursion Theorem}{
    Let \(A\) be a set, \(a \in A\), and \(g \colon A \times \NN \to A\).
    Then, there uniquely exists an infinite sequence \(f \colon \NN \to A\) such that
    \begin{enumerate}[nolistsep, label=(\roman*)]
        \ii \(f_0 = a\) and
        \ii \(\fall n \in \NN,\: f_{n+1} = g(f_n, n)\).
    \end{enumerate}
}
\pf{Proof}{
    We say \(t \colon (m + 1) \to A\) is an \textit{\(m\)-step computation based on \(a\) and \(g\)}
    if \(t_0 = a\) and \(\fall k < m,\: t_{k+1} = g(t_k, k)\).
    Let \(F \triangleq \{\,t \in \Seq(A) \mid t \text{ is an \(m\) step computation for some \(m \in \NN\)}\,\}\).
    Let \(f \triangleq \bigcup F\).

    \clm[3.3.2.fIsFunction]{
        \(f\) is a function.
    }{
        We shall show that \(F\) is a compatible system of functions
        so we may conclude \(f\) is a function thanks to \Cref{th:compatibleThenUnionIsFunction}.
        Take any \(t, u \in F\).
        Let \(n = \dom t \in \NN\) and \(m = \dom u \in \NN\).
        \WLOG, \(n \le m\) (thanks to \nameref{th:NisLinearlyOrdered}), i.e., \(n \subseteq m\).
        Hence, \((\dom t) \cap (\dom u) = n\).
        If \(n = 0\), then it is done; assume \(n > 0\).
        Then, there exists \(n' \in \NN\) such that \(n' + 1 = n\) by \Cref{exer:3.2.4}.

        Surely, \(t_0 = a = u_0\).
        Moreover, if \(t_k = u_k\) where \(k < n'\),
        then \(k+1 < n'+1 = n\) (\Cref{exer:3.2.2}) and \(t_{k+1} = g(t_k, k) = g(u_k, k) = u_{k+1}\).
        Therefore, by \nameref{exer:3.2.12}, we have \(\fall k \le n',\: t_k = u_k\);
        \(t\) and \(u\) are compatible.
        \qed
    }

    \clm[3.3.2.domfisN]{
        \(\dom f = \NN\) and \(\ran f \subseteq A\).
    }{
        We already have \(\dom f \subseteq \NN\) and \(\ran f \subseteq A\) by \Cref{th:compatibleThenUnionIsFunction}.
        To show \(\dom f = \NN\), it suffices to show that, for any \(n \in \NN\), there is an
        \(n\)-step computation based on \(a\) and \(g\). Clearly, \(t = \{(0, a)\}\)
        is a \(0\)-step computation.

        Assume there exists an \(n\)-step computation \(t \colon (n+1) \to A\) where \(n \in \NN\).
        Then, define \(u \colon ((n+1)+1) \to A\) by
        \(u \triangleq t \cup \{(n + 1, g(t_n, n))\}\).
        Then, one may easily verify that \(u\) is an \((n+1)\)-step computation.
        Therefore, by \nameref{th:induction}, the result follows.
        \qed
    }

    \noindent
    We now check if \(f\) satisfies the conditions (i) and (ii).
    \begin{enumerate}[nolistsep, label=(\roman*)]
        \ii 
        Clearly, \(f_0 = a\).
        \ii
        Take any \(n \in \NN\).
        Let \(t\) be an \((n+1)\)-step computation.
        Then, \(\fall k \le n,\: f_k = t_k\),
        and \(f_{n+1} = t_{n+1} = g(t_n, n) = g(f_n, n)\).
    \end{enumerate}
    Now, we are left to show the uniqueness of such \(f\).

    Let \(h \colon \NN \to A\) be a sequence that satisfies the conditions (i) and (ii).
    Clearly, \(f_0 = a = h_0\). And, if \(f_n = h_n\),
    then \(f_{n+1} = g(f_n, n) = g(h_n, n) = h_{n+1}\).
    Therefore, by \nameref{th:induction}, \(\fall k \in \NN,\: f_k = h_k\),
    i.e., \(f = k\) by \Cref{lem:functionEqualsIff}.
}

\thm[]{}{
    Let \((A, \preceq)\) be a nonempty linearly ordered set with the properties:
    \begin{enumerate}[nolistsep, label=(\roman*), leftmargin=*]
        \ii For every \(p \in A\), there exists \(q \in A\) such that \(p \prec q\).
        \ii Every nonempty subset of \(A\) that has a \(\preceq\)-least element.
        \ii Every nonempty subset of \(A\) that has an upper bound has a \(\preceq\)-greatest element.
    \end{enumerate}
    Then, \((A, \preceq)\) is isomorphic to \((\NN, \le)\).
}
\pf{Proof}{
    By (i), \(\{\,a \in A \mid x \prec a\,\} \neq \OO\) for each \(x \in A\)
    and it has a \(\preceq\)-least element.
    Hence, we may define \(g \colon A \times \NN \to A\) by
    \(g(x, n) \triangleq \min \{\,a \in A \mid x \prec a\,\}\).
    Then, \nameref{th:recursion} guarantees the existence of a function \(f \colon \NN \to A\)
    such that:
    \begin{itemize}[nolistsep]
        \ii \(f_0 = \min A\) \comment{(i) and \(A \neq \OO\)}
        \ii \(\fall n \in \NN,\: f_{n+1} = g(f_n, n) = \min \{\,a \in A \mid f_n \prec a\,\}\).
    \end{itemize}
    By \Cref{exer:3.3.1}, we have \(f_m \prec f_n\) whenever \(m < n\).
    This also implies that \(f\) is injective.

    \clm[009f.fIsSurjective]{
        \(\ran f = A\)
    }{
        Suppose \(\ran f \subsetneq A\) for the sake of contradiction.
        Then, \(A \setminus \ran f \neq \OO\), and thus we may take \(p = \min (A \setminus \ran f)\),
        which gives \(p \neq f_0\) immediately.
        Hence, \(B = \{\,a \in A \mid a \prec p\,\} \neq \OO\) and \(p\) is an upper bound of \(B\).
        By (iii), \(q = \max B\) exists. Since \(q \prec p\), we have \(q \in \ran f\),
        i.e., \(q = f_m\) for some \(m \in \NN\).

        Suppose there is some \(r \in A\) such that \(q \prec r \prec p\).
        Then, \(r \in B\), which contradicts the maximality of \(q\).
        Hence, \(p = \min \{\,a \in A \mid f_m \prec a\,\} = f_{m+1}\),
        which contradicts \(p \notin \ran f\).
        \qed
    }

    We have \(f \colon \NN \hooktwoheadrightarrow A\) by \Cref{clm:009f.fIsSurjective}.
    Hence, by \nameref{th:NisLinearlyOrdered} and \Cref{lem:oneImplicationIsEnough}, \(f\) is an isomorphism 
    between \((\NN, \le)\) and (\(A, \preceq\)).
}

\thm[generalRecursion]{The Recursion Theorem: General Version}{
    Let \(S\) be a set and let \(g \colon \Seq(S) \to S\).
    Then, there exists a unique sequence \(f \colon \NN \to S\) such that
    \[
        \fall n \in \NN,\: f_n = g \left(\restr{f}{n}\right) = g(\lang\,f_0, f_1, \cdots, f_{n-1}\,\rang).
    \]
}
\pf{Proof}{
    Define \(G \colon \Seq(S) \times \NN \to \Seq(S)\) by
    \[
        G(t, n) = \begin{cases}
            t \cup \{(n, g(t))\} & \text{if \(t\) is a sequence of length \(n\)} \\
            \lang\rang & \text{otherwise}.
        \end{cases}
    \]
    Then, by \nameref{th:recursion}, there exists a sequence \(F \colon \NN \to \Seq(S)\)
    such that:
    \begin{itemize}[nolistsep]
        \ii \(F_0 = \lang\rang\)
        \ii \(\fall n \in \NN,\: F_{n+1} = G(F_n, n)\).
    \end{itemize}

    If \(F_k \in S^k\), then \(F_{k+1} = F_k \cup \{k, g(F_k)\} \in S^{k+1}\).
    Hence, by \nameref{th:induction}, \(\fall n \in \NN,\: F_n \in S^n\).
    Moreover, since \(F_k \subsetneq_{\Seq(S)} F_{k+1}\),
    by \Cref{exer:3.3.1}, \(\fall m, n \in \NN,\: (m < n \implies F_m \subsetneq F_n)\);
    hence \(\{\,F_n \mid n \in \NN\,\}\) is a compatible system of functions.

    Let \(f \triangleq \bigcup_{n \in \NN} F_n\).
    Then, we have \(\restr{f}{n} = F_n\) for all \(n \in \NN\).
    Therefore, for each \(n \in \NN\), \(f_n = F_{n+1}(n) = g(F_n) = g\left(\restr{f}{n}\right)\).

    Let \(h \colon \NN \to S\) be another sequence such that \(\fall n \in \NN,\: h_n = g\left(\restr{h}{n}\right)\).
    Suppose \(\fall k < n, f_k = h_k\).
    Then, we have \(f_{n} = g\left(\restr{f}{n}\right) = g\left(\restr{h}{n}\right) = h_{n}\).
    Therefore, by \nameref{th:strongInduction}, \(f = h\).
}

\thm[parametricRecursion]{The Recursion Theorem: Parametric Version}{
    Let \(a \colon P \to A\) and \(g \colon P \times A \times \NN \to A\) be functions.
    Then, there uniquely exists a function \(f \colon P \times \NN \to A\) such that
    \begin{enumerate}[nolistsep, label=(\roman*)]
        \ii \(\fall p \in P,\: f(p, 0) = a(p)\)
        \ii \(\fall n \in \NN,\: \fall p \in P,\: f(p, n + 1) = g(p, f(p, n), n)\).
    \end{enumerate}
}
\pf{Proof}{
    Let \(G \colon A^P \times \NN \to A^P\) be defined by
    \[
        G(x, n)(p) = g(p, x(p), n)
    \]
    for each \(x \in A^P\), \(p \in P\), and \(n \in \NN\).
    Then, by \nameref{th:recursion}, there exists \(F \colon \NN \to A^P\)
    such that
    \[
        F_0 = a \quad\text{and}\quad \fall n \in \NN,\:F_{n+1} = G(F_n, n).
    \]
    
    Now, let \(f \colon P \times \NN \to A\) be defined by
    \(f(p, n) = F_n(p)\).
    We now check if \(f\) satisfies the conditions:
    \begin{enumerate}[nolistsep, label=(\roman*), leftmargin=*]
        \ii
        For all \(p \in P\), we have \(f(p, 0) = F_0(p) = a(p)\).

        \ii
        For each \(n \in \NN\) and \(p \in P\),
        \(f(p, n+1) = F_{n+1}(p) = G(F_n, n)(p) = g(p, F_n(p), n) = g(p, f(p, n), n)\).
        
    \end{enumerate}
    
    Let \(h \colon P \times \NN \to A\) be another function that satisfies (i) and (ii).
    Clear, we have \(\fall p \in P,\: f(p, 0) = a(p) = h(p, 0)\).
    Assuming \(\fall p \in P,\: f(p, n) = h(p, n)\) gives,
    for all \(p \in P\), \(f(p, n+1) = g(p, f(p, n), n) = g(p, h(p, n), n) = h(p, n+1)\).
    Hence, by \nameref{th:induction}, we get \(f = h\).
}

\subsection*{Selected Problems}

\exer[3.3.1]{}{
    Let \(f \colon \NN \to A\) be an infinite sequence
    where \((A, \preceq)\) is an ordered set. Then,
    \[
        \fall n \in \NN,\: f_n \prec f_{n+1}
        \implies \fall m, n \in \NN,\: (n < m \implies f_n \prec f_m).
    \]
}
\pf{Proof}{
    Fix any \(n \in \NN\) and let \(\mbf{P}(x)\) be the property ``\(f_n \prec f_x\).''
    \(\mbf{P}(n+1)\) evidently holds.
    Now, suppose \(\mbf{P}(k)\) holds where \(k \in \NN\).
    Then, chaining \(f_n \prec f_k\) and \(f_k \prec f_{k+1}\) gives \(\mbf{P}(k+1)\).
    Therefore, by \Cref{exer:3.2.11}, we get \(\fall m \ge n + 1,\: f_n \prec f_m\).
}

\exer[3.3.2]{}{
    Let \((A, \preceq)\) be a nonempty linearly ordered set.
    We say that \(q \in A\) is a \textit{successor} of \(p \in A\) if there is no \(r \in A\)
    such that \(p \prec r \prec q\). Assume \((A, \preceq)\) has the following properties:
    \begin{enumerate}[nolistsep, label=(\roman*)]
        \ii Every \(p \in A\) has a successor.
        \ii Every nonempty subset of \(A\) has a \(\preceq\)-least element.
        \ii If \(p \in A\) is not the \(\preceq\)-least element of \(A\),
            then \(p\) is a successor of some \(q \in A\).
    \end{enumerate}
    Then, \((A, \preceq)\) is isomorphic to \((\NN, \le)\).
}
\pf{Proof}{
    By (i), for each \(p \in P\), \(\{\,q \in A \mid p \prec q\,\} \neq \OO\), and thus it has
    a \(\preceq\)-least element by (ii).
    Therefore, by \nameref{th:recursion}, there exists a sequence \(f \colon \NN \to A\)
    such that \(f_0 = \min A\) and \(\fall n \in \NN,\: f_{n+1} = \min \{\,q \in A \mid f_n \prec q\,\}\).

    \clm[88332b22]{
        \(\ran f = A\)
    }{
        Suppose \(X \triangleq A \setminus \ran f \neq \OO\) for the sake of contradiction.
        Then, by (ii), we may take \(p = \min X\).
        Since \(\min A = f_0 \in \ran f\), \(p\) is not the \(\preceq\)-least element of \(A\).
        Hence, by (iii), \(p\) is a successor of some \(q \in A\).
        As \(q \prec p\), we have \(q \in \ran f\) by minimality of \(q\),
        i.e., \(q = f_m\) for some \(m \in \NN\).
        Since there is no \(r \in A\) such that \(q \prec r \prec p\),
        we have \(p = f_{m+1}\) by definition,
        which contradicts \(p \notin \ran f\). \qed
    }
    Since \(f_n \prec f_{n+1}\) for all \(n \in \NN\),
    by \Cref{exer:3.3.1}, \(\fall m, n \in \NN,\: (m < n \implies f_m \prec f_n)\),
    which means \(f\) is injective.

    Therefore, together with \Cref{clm:88332b22}, \(f\) is an isomorphism between
    \((\NN, \le)\) and \((A, \preceq)\) by \Cref{lem:oneImplicationIsEnough}.
}

\setexernumber{4}

\exer[3.3.5]{The Recursion Theorem: Finite Version}{
    Let \(g\) be a function such that \(\dom g \subseteq A \times \NN\) and \(\ran g \subseteq A\).
    Let \(a \in A\).
    Then, there uniquely exists a sequence \(f\) of elements of \(A\) such that
    \begin{enumerate}[nolistsep, label=(\roman*)]
        \ii \(f_0 = a\)
        \ii \(\fall n \in \NN,\: [n+1 \in \dom f \implies f_{n+1} = g(f_n, n)]\)
        \ii \(f\) is either an infinite sequence or a finite sequence of length \(k+1\) and \((f_k, k) \notin \dom g\).
    \end{enumerate}
}
\pf{Proof}{
    Let \(\ol{A} = A \cup \{\ol{a}\}\) where \(\ol{a} \notin A\).
    (Such \(\ol{a}\) exists by \Cref{exer:1.3.3} (ii).)
    Define \(\ol{g} \colon \ol{A} \times \NN \to \ol{A}\) by
    \[
        \ol{g}(x, n) = \begin{cases}
            g(x, n) & \text{if \((x, n) \in \dom g\)} \\
            \ol{a} & \text{otherwise.}
        \end{cases}
    \]
    Then, \nameref{th:recursion} guarantees the existence of \(\ol{f} \colon \NN \to \ol{A}\)
    such that \(\ol f_0 = a\) and \(\fall n \in \NN,\: \ol f_{n+1} = \ol g(\ol f_n, n)\).
    We have two cases: ``\(\fall n \in \NN,\: \ol{f}_{n} \neq \ol{a}\)'' and ``\(\exs n \in \NN,\: \ol f_n = \ol{a}\).''
    They are resolved by \Cref{clm:7a376003,clm:db06f79c}, respectively.

    \clm[7a376003]{
        If ``\(\fall n \in \NN,\: \ol{f}_{n} \neq \ol{a}\),''
        then \(\ol{f}\) is an infinite sequence of elements of \(A\) that satisfies (i) and (ii).
    }{
        The assumption essentially says that
        \((\ol f_n, n) \in \dom g\) and \(\ol f_{n+1} = g(\ol f_n, n) \in A\) for all \(n \in \NN\),
        i.e., \(\ol f\) satisfies (i) and (ii).
        As \(\ol f_0 = a \in A\), \(\ol f\) is an infinite sequence of elements of \(A\).
        \qed
    }

    \clm[db06f79c]{
        If ``\(\exs n \in \NN,\: \ol f_n = \ol{a}\),''
        then there exists \(k \in \NN\) such that
        \(\restr{\ol{f}}{k+1}\) satisfies the conditions (i), (ii), and (iii).
    }{
        By \nameref{th:NisWellOrdered}, we have \(\ell \triangleq \min \{\,n \in \NN \mid \ol f_n = \ol{a}\,\}\).
        Since \(\ol f_0 \in A\), we have \(\ell \neq 0\), and thus \(\ell = k + 1\) for some \(k \in \NN\)
        by \Cref{exer:3.2.4}.
        It immediately follows that \(\fall n \le k,\: \ol{f}_n \in A\).
        Hence, \(f \triangleq \restr{\ol f}{k+1}\) is a finite sequence of length \(k+1\)
        of elements of \(A\).

        We check if \(f\) satisfies the conditions (i), (ii), and (iii):
        \begin{enumerate}[nolistsep, label=(\roman*), leftmargin=*]
            \ii \(f_0 = \ol{f}_0 = a\)
            \ii 
            If \(n < k\), i.e., \(n + 1 \in \dom f = k + 1\),
            then \(f_{n+1} = \ol{f}_{n+1} = \ol g(\ol{f}_n, n) = g(f_n, n)\).
            \ii
            If \((f_k, k) \in \dom g\), then we would have
            \(\ol{f}_\ell = \ol g(\ol{f}_k, k) = \ol g(f_k, k) = g(f_k, k) \neq \ol{a}\).
            Hence, we must have \((f_k, k) \notin \dom g\). \qed
        \end{enumerate}
    }

    Now, we prove the uniqueness.
    Let \(f\) and \(h\) be two sequences of elements of \(A\)
    that satisfies the conditions (i), (ii), and (iii).
    \textsf{WLOG}, \(\dom h \subseteq \dom f\).

    Let \(\mbf{P}(x)\) be the property ``\(x \in \dom h \land f_x = h_x\).''
    \(\mbf{P}(0)\) evidently holds.
    \clm[e3045233]{
        \(\fall n \in \NN,\: (n + 1 \in \dom f \land \mbf{P}(n) \implies \mbf{P}(n+1))\)
    }{
        Assume \(n + 1 \in \dom f\) and \(\mbf{P}(n)\).
        Then, since \((h_n, n) = (f_n, n) \in \dom g\),
        \(n + 1 \in \dom h\) and \(h_{n+1} = g(h_n, n) = g(f_n, n) = f_{n+1}\).
        Hence, \(\mbf{P}(n+1)\) holds. \qed
    }

    If \(f\) is a finite sequence, \Cref{clm:e3045233} and \nameref{exer:3.2.12}
    imply \(h = f\).
    If \(f\) is an infinite sequence, \Cref{clm:e3045233} and \nameref{th:induction}
    imply \(h = f\).
}

\exer[3.3.6]{}{
    If \(X \subseteq \NN\), then there is a one-to-one (finite or infinite) sequence
    \(f\) such that \(\ran f = X\).
}
\pf{Proof}{
    If \(X = \OO\), \(\lang\rang\) is the one we are looking for.
    Assume \(X \neq \OO\).

    Let \(g = \big\{\,((x, n), y) \in (X \times \NN) \times X \:\big|\: y = \min \{\,k \in X \mid x < k\,\}\,\big\}\).
    Then, \(g\) is a function with \(\dom g \subseteq \NN \times \NN\) and \(\ran g \subseteq \NN\).
    By \nameref{exer:3.3.5}, there exists a sequence \(f\) of elements of \(X\)
    such that
    \begin{enumerate}[nolistsep, label=(\roman*)]
        \ii \(f_0 = \min X\) \comment{\(\min X\) exists by \nameref{th:NisWellOrdered}}
        \ii \(\fall n \in \NN,\: (n + 1 \in \dom f \implies f_{n+1} = g(f_n, n))\)
        \ii \(f\) is either an infinite sequence or a finite sequence of length \(k+1\) and \((f_k, k) \notin \dom g\).
    \end{enumerate}
    
    Note that \(\dom g = \{\,(x, n) \in X \times \NN \mid \exs y \in X,\: x < y\,\}\).
    Moreover, for each \(n \in \NN\) such that \(n + 1 \in \dom f\),
    we have \(f_n < f_{n+1}\); hence \(\forall m, n \in \dom f,\: (m < n \implies f_m < f_n)\)
    (in the similar manner of \Cref{exer:3.3.1}),
    and thus \(f\) is injective.

    Suppose \(Y = X \setminus \ran f \neq \OO\) for the sake of contradiction.
    By \nameref{th:NisWellOrdered}, we may take \(y = \min Y\).
    Then, by \Cref{th:hasUpperBoundThenMaxExists}, we may let \(z = \max \{\,x \in X \mid x < y\,\}\).
    \(z = f_m\) for some \(m \in \dom f\). Hence, \(y = f_{m+1}\).
}

\section{Arithmetic of Natural Numbers}

\thm[additionExists]{}{
    There uniquely exists a function \(\mathord{+} \colon \NN \times \NN \to \NN\) such that
    \begin{enumerate}[nolistsep, label=(\roman*))]
        \ii \(\fall m \in \NN,\: \mathord{+}(m, 0) = m\)
        \ii \(\fall m, n \in \NN,\: \mathord{+}(m, n+1) = S(\mathord{+}(m, n))\).
    \end{enumerate}
}
\pf{Proof}{
    The result directly follows from exploiting
    \nameref{th:parametricRecursion} with \(A = P = \NN\), \(a(p) = p\) for all \(p \in \NN\),
    and \(g(p, x, n) = S(x)\) for all \(p, x, n \in \NN\).
}

\dfn[addition]{Addition}{
    The function \(+\) defined in \Cref{th:additionExists}
    is called the \textit{addition}.
}

\notat[addition]{}{
    For all \(m \in \NN\), we have
    \(\mathord{+}(m, 1) = \mathord{+}(m, 0+1) = \mathord{+}(m, 0) + 1 = m + 1\).
    Hence, we may write \(m + n\) instead of \(\mathord{+}(m, n)\)
    without causing any confusion regarding \Cref{not:nPlusOne}.
    We restate the defining properties of the addition for future reference:
    \begin{equation}
        \fall m \in \NN,\: m + 0 = m \label{eq:addition1}\tag{\(1\)}
    \end{equation}
    \begin{equation}
        \fall m, n \in \NN,\: m + (n + 1) = (m + n) + 1 \label{eq:addition2}\tag{\(2\)}
    \end{equation}
}

\thm[addIsCommutative]{\(+\) is Commutative}{
    Addition is commutative; that is to say
    \[
        \fall m, n \in \NN,\: m + n = n + m.
    \]
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property ``\(\fall m \in \NN,\: m + x = x + m\).''
    \clm[e3d019c6]{
        \(\mbf{P}(0)\) holds.
    }{
        Since \(m + 0 = m\) already, we only need to prove \(0 + m = m\) for all \(m \in \NN\).
        We shall make use of induction.
        First of all \(0 + 0 = 0\) holds by \eqref{eq:addition1}.

        Suppose \(0 + m = m\) where \(m \in \NN\). Then,
        \begin{alignat*}{2}
            0 + (m + 1) &= (0 + m) + 1 &\qquad& \comment*{\eqref{eq:addition2}} \\
                        &= m + 1. &\qquad& \comment*{\(0 + m = m\)}
        \end{alignat*}
        Hence, by \nameref{th:induction}, \(0 + m = m\) for all \(m \in \NN\). \qed
    }

    \clm[688efe85]{
        \(\fall n \in \NN,\: [\mbf{P}(n) \implies \mbf{P}(n+1)]\)
    }{
        Assume \(\mbf{P}(n)\).
        We shall show \(\mbf{P}(n+1)\) holds by induction.
        \(0 + (n+1) = (n+1) + 0\) is already shown by \Cref{clm:e3d019c6}.
        Hence, assume \(m + (n+1) = (n+1) + m\) for fixed \(m \in \NN\).
        Then,
        \begin{alignat*}{2}
            (m+1) + (n+1) &= ((m+1) + n) + 1 &\qquad& \comment*{\eqref{eq:addition2}}\\
                          &= (n + (m + 1)) + 1 &\qquad& \comment*{\(\mbf{P}(n)\)}\\
                          &= ((n + m) + 1) + 1 &\qquad& \comment*{\eqref{eq:addition2}}\\
                          &= ((m + n) + 1) + 1 &\qquad& \comment*{\(\mbf{P}(n)\)}\\
                          &= (m + (n + 1)) + 1 &\qquad& \comment*{\eqref{eq:addition2}}\\
                          &= ((n + 1) + m) + 1 &\qquad& \comment*{\(m + (n+1) = (n+1) + m\)}\\ 
                          &= (n + 1) + (m + 1). &\qquad& \comment*{\eqref{eq:addition2}}
        \end{alignat*}
        Hence, by \nameref{th:induction}, \(\mbf{P}(n+1)\) holds. \qed
    }

    \noindent
    From \Cref{clm:e3d019c6}, \Cref{clm:688efe85}, and \nameref{th:induction},
    we get \(\fall m, n \in \NN,\: m + n = n + m\).
}

\thm[addIsAssociative]{\(+\) is Associative}{
    Addition is associative; that is to say
    \[
        \fall k, m, n \in \NN,\: (k + m) + n = k + (m + n).
    \]
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property ``\(\fall k, m \in \NN,\: (k + m) + x = k + (m + x)\).''
    \(\mbf{P}(0)\) is direct by \eqref{eq:addition1}.

    Now, fix any \(n \in \NN\) and assume \(\mbf{P}(n)\).
    Then, for all \(k, m \in \NN\),
    \begin{alignat*}{2}
        (k + m) + (n + 1) &= ((k + m) + n) + 1 &\qquad& \comment*{\eqref{eq:addition2}}\\
                          &= (k + (m + n)) + 1 &\qquad& \comment*{\(\mbf{P}(n)\)}\\
                          &= k + ((m + n) + 1) &\qquad& \comment*{\eqref{eq:addition2}}\\
                          &= k + (m + (n + 1)). &\qquad& \comment*{\eqref{eq:addition2}}
    \end{alignat*}
    Hence, by \nameref{th:induction}, the result follows.
}

\thm[multiplicationExists]{}{
    There uniquely exists a function \(\mathord{\cdot} \colon \NN \times \NN \to \NN\) such that
    \begin{enumerate}[nolistsep, label=(\roman*)]
        \ii \(\fall m \in \NN,\: m \cdot 0 = 0\)
        \ii \(\fall m, n \in \NN,\: m \cdot (n + 1) = m \cdot n + m\).
    \end{enumerate}
}
\pf{Proof}{
    The result directly follows from exploiting
    \nameref{th:parametricRecursion} with \(A = P = \NN\), \(a(p) = 0\) for all \(p \in \NN\),
    and \(g(p, x, n) = x + p\) for all \(p, x, n \in \NN\).
}

\dfn[multiplication]{Multiplication}{
    The function \(\cdot\) defined in \Cref{th:multiplicationExists}
    is called the \textit{multiplication}.
    \begin{equation}
        \fall m \in \NN,\: m \cdot 0 = 0 \label{eq:multiplication1}\tag{\(3\)}
    \end{equation}
    \begin{equation}
        \fall m, n \in \NN,\: m \cdot (n+1) = m \cdot n + m \label{eq:multiplication2}\tag{\(4\)}
    \end{equation}
}

\thm[multIsCommutative]{\(\cdot\) is Commutative}{
    Multiplication is commutative, i.e., 
    \[\fall m, n \in \NN,\: m \cdot n = n \cdot m.\]
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property ``\(\fall m \in \NN,\: m \cdot x = x \cdot m\).''
    \clm[30d818bf]{
        \(\mbf{P}(0)\) holds.
    }{
        Since \(m \cdot 0 = 0\) already by \eqref{eq:multiplication1},
        we only need to prove \(0 \cdot m = 0\) for all \(m \in \NN\).
        We shall make use of induction.
        First of all \(0 \cdot 0 = 0\) holds by \eqref{eq:multiplication1}.

        Suppose \(0 \cdot m = 0\) where \(m \in \NN\). Then,
        \begin{alignat*}{2}
            0 \cdot (m + 1) &= 0 \cdot m + 0 &\qquad& \comment*{\eqref{eq:multiplication2}} \\
                        &= 0 + 0 &\qquad& \comment*{\(0 \cdot m = 0\)} \\
                        &= 0.
        \end{alignat*}
        Hence, by \nameref{th:induction}, \(0 \cdot m = 0\) for all \(m \in \NN\). \qed
    }

    \clm[11595ce5]{
        \(\fall n \in \NN,\: [\mbf{P}(n) \implies \mbf{P}(n + 1)]\)
    }{
        Fix any \(n \in \NN\) and assume \(\mbf{P}(n)\).
        We shall prove \(\mbf{P}(n + 1)\) by induction.
        We already have \(0 \cdot (n + 1) = (n + 1) \cdot 0\) by \Cref{clm:30d818bf}.

        Fix any \(m \in \NN\) and assume \(m \cdot (n + 1) = (n + 1) \cdot m\).
        Then,
        \begin{alignat*}{2}
            (m + 1) \cdot (n + 1) &= (m + 1) \cdot n + (m + 1) &\qquad& \comment*{\eqref{eq:multiplication2}}\\
                                  &= n \cdot (m + 1) + (m + 1) && \comment*{\(\mbf{P}(n)\)}\\
                                  &= (n \cdot m + n) + (m + 1) && \comment*{\eqref{eq:multiplication2}}\\
                                  &= (m \cdot n + n) + (m + 1) && \comment*{\(\mbf{P}(n)\)}\\
                                  &= (m \cdot n + m) + (n + 1) && \comment*{\nameref{th:addIsCommutative}, \nameref{th:addIsAssociative}}\\
                                  &= m \cdot (n + 1) + (n + 1) && \comment*{\eqref{eq:multiplication2}}\\
                                  &= (n + 1) \cdot m + (n + 1) && \comment*{\(m \cdot (n + 1) = (n + 1) \cdot m\)}\\
                                  &= (n + 1) \cdot (m + 1). && \comment*{\eqref{eq:multiplication2}}\\
        \end{alignat*}
        Hence, by \nameref{th:induction}, \(\mbf{P}(n + 1)\) holds.
    }

    \noindent
    From \Cref{clm:30d818bf}, \Cref{clm:11595ce5}, and \nameref{th:induction},
    we get \(\fall m, n \in \NN,\: m \cdot n = n \cdot m\).
}

\thm[multDistrOverAdd]{\(\cdot\) Distributes Over \(+\)}{
    Multiplication is distributive over addition, i.e.,
    \begin{alignat*}{1}
        & \fall k, m, n \in \NN,\: k \cdot (m + n) = k \cdot m + k \cdot n \quad\text{and}\\
        & \fall k, m, n \in \NN,\: (m + n) \cdot k = m \cdot k + n \cdot k.
    \end{alignat*}
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property ``\(\fall k, m \in \NN,\: k \cdot (m + x) = k \cdot m + k \cdot x\).''
    \(\mbf{P}(0)\) holds by \eqref{eq:addition1} and \eqref{eq:multiplication1}.
    
    Fix any \(n \in \NN\) and assume \(\mbf{P}(n)\).
    Then, for each \(k, m \in \NN\),
    \begin{alignat*}{2}
        k \cdot (m + (n + 1)) &= k \cdot ((m + n) + 1) &\qquad& \comment*{\nameref{th:addIsAssociative}}\\
                              &= k \cdot (m + n) + k && \comment*{\eqref{eq:multiplication2}}\\
                              &= (k \cdot m + k \cdot n) + k && \comment*{\(\mbf{P}(n)\)}\\
                              &= k \cdot m + (k \cdot n + k) && \comment*{\nameref{th:addIsAssociative}}\\ 
                              &= k \cdot m + k \cdot (n + 1). && \comment*{\eqref{eq:multiplication2}}
    \end{alignat*}
    Hence, by \nameref{th:induction}, we have \(\fall k, m, n \in \NN,\: k \cdot (m + n) = k \cdot m + k \cdot n\).

    Now, we have, for each \(k, m, n \in \NN\),
    \begingroup\setlength{\belowdisplayskip}{0pt}
    \begin{alignat*}{2}
        (m + n) \cdot k &= k \cdot (m + n) &\qquad& \comment*{\nameref{th:multIsCommutative}}\\
                        &= k \cdot m + k \cdot n \\
                        &= m \cdot k + n \cdot k. && \comment*{\nameref{th:multIsCommutative}}
    \end{alignat*}
    \endgroup
}

\thm[multIsAssociative]{\(\cdot\) is Associative}{
    Multiplication is associative, i.e.,
    \[
        \fall k, m, n \in \NN,\: (k \cdot m) \cdot n = k \cdot (m \cdot n).
    \]
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property ``\(\fall k, m \in \NN,\: (k \cdot m) \cdot x = k \cdot (m \cdot x)\).''
    \(\mbf{P}(0)\) is direct from \eqref{eq:multiplication1}.

    Fix any \(n \in \NN\) and assume \(\mbf{P}(n)\). Then, for each \(k, m \in \NN\),
    \begin{alignat*}{2}
        (k \cdot m) \cdot (n + 1)
          &= (k \cdot m) \cdot n + k \cdot m &\qquad& \comment*{\eqref{eq:multiplication2}} \\
          &= k \cdot (m \cdot n) + k \cdot m && \comment*{\(\mbf{P}(n)\)} \\
          &= k \cdot (m \cdot n + m) && \comment*{\nameref{th:multDistrOverAdd}} \\ 
          &= k \cdot (m \cdot (n + 1)). && \comment*{\eqref{eq:multiplication2}}
    \end{alignat*}
    Hence, the result follows by \nameref{th:induction}.
}

\subsection*{Selected Problems}

\setexernumber{1}

\exer[3.4.2]{}{
    \(\fall k, m, n \in \NN,\: (m < n \iff m + k < n + k)\)
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property ``\(\fall m, n \in \NN,\: (m < n \iff m + x < n + x)\).''
    \(\mbf{P}(0)\) is evident from \eqref{eq:addition1}.

    Now, fix any \(k \in \NN\) and assume \(\mbf{P}(k)\).
    Then, for all \(m, n \in \NN\),
    \begin{alignat*}{2}
        m < n &\iff m + k < n + k &\qquad& \comment*{\(\mbf{P}(k)\)}\\
              &\iff (m + k) + 1 < (n + k) + 1 && \comment*{\Cref{exer:3.2.2}}\\
              &\iff m + (k + 1) < n + (k + 1). && \comment*{\nameref{th:addIsAssociative}}
    \end{alignat*}
    By \nameref{th:induction}, the result follows.
}

\exer[3.4.3]{}{
    \(\fall m, n \in \NN,\: (m \le n \iff \exs! k \in \NN,\: n = m + k)\)
}
\pf{Proof}{
    (\(\Rightarrow\))
    Fix any \(m \in \NN\) and let \(\mbf{P}(x)\) be the property ``\(\exs k \in \NN,\: x = m + k\).''
    \(\mbf{P}(m)\) holds since \(k = 0\) would satisfy by \eqref{eq:addition1}.

    Fix any \(n \in \NN\) such that \(m \le n\) and assume \(\mbf{P}(n)\).
    Then, there exists \(k\) such that \(n = m + k\),
    which leads to \(n + 1 = m + (k + 1)\) by \nameref{th:addIsAssociative}.
    Hence, \(\mbf{P}(n+1)\) holds.
    Therefore, \(\fall n \ge m,\: \exs k \in \NN,\: n = m + k\) by \Cref{exer:3.2.11}.

    To prove the uniqueness, assume \(m + k = m + \ell\) where \(k, \ell, m \in \NN\).
    \WLOG, \(k \le \ell\). If it were \(k < \ell\), by \Cref{exer:3.4.2} and \nameref{th:addIsCommutative},
    we must have \(m + k = k + m < \ell + m = \ell + m\).
    Hence, \(k = \ell\).

    (\(\Leftarrow\))
    Let \(\mbf{P}(x)\) be the property ``\(\fall m, n \in \NN,\: (n = m + x \implies m \le n)\).''
    We have evidently \(\mbf{P}(0)\) by \eqref{eq:addition1}.

    Fix any \(k \in \NN\) and assume \(\mbf{P}(k)\).
    Then, for each \(m, n \in \NN\) such that \(n = m + (k + 1)\), we have
    \(n = (m + 1) + k\) thanks to \nameref{th:addIsCommutative} and \nameref{th:addIsAssociative},
    and thus \(m < m + 1 \le n\) by \(\mbf{P}(k)\).
    Hence, by \nameref{th:induction}, the result follows.
}

\setexernumber{5}

\exer[3.4.6]{}{
    \(\fall k, m, n \in \NN,\: [k \neq 0 \implies (m < n \iff m \cdot k < n \cdot k)]\)
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property ``\(\fall m, n \in \NN,\: (m < n \iff m \cdot k < n \cdot k)\).''
    \(\mbf{P}(1)\) holds since, for all \(n \in \NN\),
    \begin{alignat*}{2}
        n \cdot 1 &= n \cdot (0 + 1) &\qquad& \comment*{\eqref{eq:addition1}, \nameref{th:addIsCommutative}}\\
                  &= n \cdot 0 + n && \comment*{\eqref{eq:multiplication2}}\\
                  &= 0 + n && \comment*{\eqref{eq:multiplication1}}\\
                  &= n. && \comment*{\eqref{eq:addition1}, \nameref{th:addIsCommutative}}
    \end{alignat*}

    Now, fix any \(k \in \NN\) and assume \(\mbf{P}(k)\).
    Then, for each \(m, n \in \NN\) with \(m < n\),
    \begin{alignat*}{2}
        m \cdot (k + 1) &= m \cdot k + m &\qquad& \comment*{\eqref{eq:multiplication2}}\\
                        &< m \cdot k + n && \comment*{\Cref{exer:3.4.2}}\\
                        &< n \cdot k + n && \comment*{\(\mbf{P}(k)\), \nameref{th:addIsCommutative}, \Cref{exer:3.4.2}}\\
                        &= n \cdot (k + 1). && \comment*{\eqref{eq:multiplication2}}
    \end{alignat*}
    Therefore, by \Cref{exer:3.2.11}, the result follows.
}

\section{Operations and Structures}

\dfn[operation]{Operation}{
    \begin{itemize}[nolistsep]
        \ii A \textit{unary operation} on \(S\) is a function on a subset of \(S\) into \(S\).
        \ii A \textit{binary operation} on \(S\) is a function on a subset of \(S^2\) into \(S\).
    \end{itemize}
}

\notat{Binary Operation}{
    Non-letter symbols such as \(+\), \(\times\), \(\ast\), \(\vartriangle\), etc.,
    are often used to denote operations.
    The value of the operation \(\ast\) at \((x, y)\) is then denoted
    \(x \ast y\) rather than \(\ast(x, y)\).
}

\dfn[closed]{Closedness Under Operation}{
    Let \(f\) be a binary operation on \(S\) and \(A \subseteq S\).
    \(A\) is said to be \textit{closed under the operation \(f\)}
    if \(\fall x, y \in A,\: [(x, y) \in \dom f \implies f(x, y) \in A]\).
}

\dfn[nTuple]{\(\boldsymbol{n}\)-Tuple}{
    Let \(n \in \NN\).
    An \(n\)-tuple is a finite sequence of length \(n\).
}

\nt{
    Let \(\lang\,a_0, \cdots, a_{n-1}\,\rang\) and \(\lang\,b_0, \cdots, b_{n-1}\,\rang\) be two \(n\)-tuples.
    We have, by \Cref{lem:functionEqualsIff},
    \[
        \lang\,a_0, \cdots, a_{n-1}\,\rang = \lang\,b_0, \cdots, b_{n-1}\,\rang
        \iff \fall i < n,\: a_i = b_i.
    \]
    This satisfies the usual defining property of \(n\)-tuple.
}

\nt{
\begin{itemize}[nolistsep, leftmargin=*]
    \ii 
    If \(\lang\, A_i \mid 0 \le i < n\,\rang\) is a finite sequence (of sets),
    then the product of the indexed system of sets \(\prod_{0 \le i < n} A_i\) (\Cref{dfn:productIndexedSystemOfSets})
    is just the set of all \(n\)-tuples \(a = \lang\,a_0, \cdots, a_{n-1}\,\rang\) such that
    \(\fall i < n,\: a_i \in A_i\).

    \ii
    If \(\fall i < n, A_i = A\), then \(\prod_{0 \le i < n} A_i = A^n\).

    \ii \(A^0 = \{\lang\rang\}\).
\end{itemize}
}

\notat{}{
    \setlength{\parindent}{1.5em}
    The `ordered pair' (\Cref{dfn:orderedPair}), \((a_0, a_1) = \{\{a_0\}, \{a_0, a_1\}\}\),
    is different set from the `\(2\)-tuple' (\Cref{dfn:nTuple}), \(\lang a_0, a_1\rang = \{(0, a_0), (1, a_1)\}\).
    Consequently, \(A_0 \times A_1\) (\Cref{dfn:cartesianProduct}) does not generally
    equal to \(\prod_{0 \le i < 2} A_i\) (\Cref{dfn:productIndexedSystemOfSets}).

    However, since there is a natural one-to-one correspondence
    \begin{align*}
       \delta : A_0 \times A_1 &\longhooktwoheadrightarrow \textstyle\prod_{0 \le i < 2} A_i \\
       (a_0, a_1) &\longmapsto \lang a_0, a_1 \rang,
    \end{align*}
    for almost all practical purposes---when only the defining property of \(n\)-tuple is needed)---%
    it makes so difference which definition one uses.

    Therefore, we do not distinguish between ordered pairs and \(2\)-tuples now on.
    That is to say we use notations
    \[
        \lang\,a_0, \cdots, a_{n-1}\,\rang \quad\text{and}\quad
        (a_0, \cdots, a_{n-1})
    \]
    interchangeably from now on.
}

\dfn[nAryOperation]{\(\boldsymbol{n}\)-ary Relation}{
    An \textit{\(n\)-ary relation} \(R\) in \(A\) is a subset of \(A^n\).
    We write \(R(a_0, a_1, \cdots, a_{n-1})\) instead of \(\lang a_0, a_1, \cdots, a_{n-1}\rang \in R\).
}

\dfn[nAryOperation]{\(\boldsymbol{n}\)-ary Operation}{
    An \textit{\(n\)-ary operation} \(F\) on \(A\) is a function on a subset of \(A^n\) into \(A\).
    We write \(F(a_0, a_1, \cdots, a_{n-1})\) instead of \(F(\lang a_0, a_1, \cdots, a_{n-1}\,\rang)\).
}

\nt{
\begin{itemize}[nolistsep, leftmargin=*]
    \ii \(1\)-ary relations in \(A\) need not be distinguished from subsets of \(A\).
    \ii \(1\)-ary operations on \(A\) need not be distinguished from functions on a subset of \(A\) into \(A\).
    \ii Nonempty \(0\)-ary operations on \(A\) need not be distinguished from \(A\).
        (A nonempty \(0\)-ary operation is of the form \(\{(\lang\rang, a)\}\) where \(a \in A\);
        a nonempty \(0\)-ary operation is called a \textit{constant}.)
\end{itemize}
}

\dfn[structure]{Structure}{
    \begin{itemize}[nolistsep, leftmargin=*]
        \ii
        A \textit{type} \(\tau\) is an ordered pair \((\lang\,r_0, \cdots, r_{m-1}\,\rang, \lang\,f_0, \cdots, f_{n-1}\,\rang)\)
        of finite sequences of natural numbers.

        \ii
        A \textit{structure of type \(\tau\)} is a triple
        \[
            \mfr{A} = (A, \lang\,R_0, \cdots, R_{m-1}\,\rang, \lang\,F_0, \cdots, F_{n-1}\,\rang)
        \]
        where \(R_i\) is an \(r_i\)-ary relation on \(A\) for each \(i < m\)
        and \(F_j\) is an \(f_j\)-ary operation on \(A\) for each \(j < n\).
        In addition, we require \(F_j \neq \OO\) if \(f_j = 0\),
        i.e., \(F_j\) should be constant.
        \(A\) is called the \textit{universe} of the structure \(\mfr{A}\).
    \end{itemize}
}

\exmp{}{
    \noindent
    \(\mfr{N} = (\NN, \lang\le\rang, \lang 0, +, \cdot\rang)\) is a structure of type
    \((\lang 2 \rang, \lang 0, 2, 2 \rang)\).
}

\notat{}{
    We often write the structure of type \((\lang\,r_0, \cdots, r_{m-1}\,\rang, \lang\,f_0, \cdots, f_{n-1}\,\rang)\)
    as a \((1 + m + n)\)-tuple, for example, \((\NN, \le, 0, +, \cdot)\),
    when it is understood which symbol represent relations and which operations.
}

\dfn[]{Isomorphism Between Structures}{
    Let \(\mfr{A}\) and \(\mfr{A}'\) be structures of the same type \(\tau = (\lang\,r_0, \cdots, r_{m-1}\,\rang, \lang\,f_0, \cdots, f_{n-1}\,\rang)\).
    Write \(\mfr{A} = (A, \lang\,R_0, \cdots, R_{m-1}\,\rang, \lang\,F_0, \cdots, F_{n-1}\,\rang)\)
    and \(\mfr{A}' = (A', \lang\,R'_0, \cdots, R'_{m-1}\,\rang, \lang\,F'_0, \cdots, F'_{n-1}\,\rang)\).
    An \textit{isomorphism} between structures \(\mfr{A}\) and \(\mfr{A}'\)
    is a mapping \(h \colon A \hooktwoheadrightarrow A'\) such that
    \begin{enumerate}[nolistsep, label=(\roman*), leftmargin=*]
        \ii
        \(\fall i < m,\: \fall a \in A^{r_i},\: [R_i(a_0, \cdots, a_{r_i-1}) \iff R'_i(h(a_0), \cdots, h(a_{r_i}-1))]\)
        \ii
        \(
            \fall j < n,\: \fall a \in A^{f_j},
            \big[(a_0, \cdots, a_{f_j-1}) \in \dom F_j \iff (h(a_0), \cdots, h(a_{f_j-1})) \in \dom F'_j\big]
        \)
        \ii
        \(\begin{aligned}[t]
            \fall j < n,\: \fall a \in A^{f_j},
            \big[&(a_0, \cdots, a_{f_j-1}) \in \dom F_j \\
             &\implies h(F_j(a_0, \cdots, a_{f_j-1})) = F'_j(h(a_0), \cdots, h(a_{f_j-1}))\big].
        \end{aligned}\)
    \end{enumerate}
}

\dfn[]{Automorphism}{
    An isomorphism between a structure \(\mfr{A}\) and itself is called an \textit{automorphism}.
}

\dfn[]{Closed Set}{
    Fix a structure \(\mfr{A} = (A, \lang\,R_0, \cdots, R_{m-1}\,\rang, \lang\,F_0, \cdots, F_{n-1}\,\rang)\).
    A set \(B \subseteq A\) is called \textit{closed} if
    \[
        \fall j < n,\: \fall  a \in B^{f_j},\: [ (a_0, \cdots, a_{f_j-1}) \in \dom F_j \implies F_j(a_0, \cdots, a_{f_j-1}) \in B].
    \]
}

\dfn[closure]{Closure}{
    Fix a structure \(\mfr{A} = (A, \lang\,R_0, \cdots, R_{m-1}\,\rang, \lang\,F_0, \cdots, F_{n-1}\,\rang)\).
    Let \(C \subseteq A\). The \textit{closure} of \(C\),
    \[
        \cl{C} \triangleq \bigcap \{\,B \subseteq A \mid C \subseteq B \text{ and }B\text{ is closed}\,\},
    \]
    is the least closed set containing all elements of \(C\).
}

\thm[]{}{
    Let \(\mfr{A} = (A, \lang\,R_0, \cdots, R_{m-1}\,\rang, \lang\,F_0, \cdots, F_{n-1}\,\rang)\)
    be a structure and let \(C \subseteq A\).
    If the sequence \(\lang\,C_i \mid i \in \NN\,\rang\) is defined recursively by
    \begin{align*}
        C_0 &= C; \\
        \fall i \in \NN,\: C_{i+1} &= C_i \cup \bigcup_{j=0}^{n-1} F_j[C_i^{f_j}],
    \end{align*}
    then \(\cl{C} = \bigcup_{i=0}^\infty C_i\).
}
\pf{Proof}{
    Note the recursive definition is justified by \nameref{th:recursion}.
    Let \(\tilde{C} \triangleq \bigcup_{i=0}^\infty C_i\).

    \clm[c7dffb1b]{
        \(\cl C \subseteq \tilde C\)
    }{
        Since we have \(C_0 \subseteq \tilde C\), it is enough to show that \(\tilde C\)
        is closed.

        Take any \(j < n\) and \(a \in \tilde{C}^{f_j}\).
        By the definition of \(\tilde C\), \(\fall r < f_j,\: \exs i_r \in \NN,\: a_r \in C_{i_{r}}\).
        We may take \(\bar \imath = \max \{\,i_r \mid r < f_j\,\}\) by \Cref{exer:3.5.13}.
        Since \(C_i \subseteq C_{i+1}\) for all \(i \in \NN\),
        we have \(a_r \in C_{i_r} \subseteq C_{\bar \imath}\) for all \(r < f_j\).
        Hence, if \((a_0, \cdots, a_{f_j-1}) \in \dom F_j\),
        we have \(F_j(a_0, \cdots, a_{f_j-1}) \in F_j[C_{\bar \imath}^{f_j}] \subseteq C_{\bar \imath + 1} \subseteq \tilde C\).
        Hence, \(\tilde C\) is closed. \qed
    }

    \clm[4bb66ea3]{
        \(\tilde C \subseteq \cl C\)
    }{
        Clearly \(C_0 = C \subseteq \cl{C}\).
        If \(C_i \subseteq \cl{C}\), then, for each \(j < n\), \(F_j[C_i^{f_j}] \subseteq \cl{C}\)
        since \(\cl{C}\) is closed.
        Hence, \(C_{i+1} \subseteq \cl{C}\).
        Therefore, by \nameref{th:induction}, \(\fall i \in \NN,\: C_i \subseteq \cl{C}\);
        hence \(\tilde C \subseteq \cl{C}\). \qed
    }
    \noindent
    Combining \Cref{clm:c7dffb1b,clm:4bb66ea3} completes the proof.
}

\thm[generalInduction]{The General Induction Principle}{
    Let \(\mfr{A} = (A, \lang\,R_0, \cdots, R_{m-1}\,\rang, \lang\,F_0, \cdots, F_{n-1}\,\rang)\)
    be a structure and let \(C \subseteq A\).
    Let \(\mbf{P}(x)\) be a property.
    If
    \begin{enumerate}[nolistsep, label=(\roman*), leftmargin=*]
        \ii \(\fall a \in C,\: \mbf{P}(a)\)
        \ii \(\fall j < n,\: \fall a \in A^{f_j},\:
            \big[ (a_0, \cdots, a_{f_j-1}) \in \dom F_j
            \land \fall i < f_j,\: \mbf{P}(a_i)
            \implies \mbf{P}(F_j(a_0, \cdots, a_{f_j-1})) \big]\)
    \end{enumerate}
    hold, then \(\fall x \in \cl{C},\: \mbf{P}(x)\).
}
\pf{Proof}{
    Let \(B = \{\,x \in A \mid \mbf{P}(x)\,\}\).
    (i) says \(C \subseteq B\) and (ii) says \(B\) is closed.
    Therefore, \(\cl{C} \subseteq B\).
}

\nt{
    \nameref{th:induction} is a special case of \nameref{th:generalInduction}
    for the structure \((\NN, S)\) where \(S\) is the successor function.
}

\subsection*{Selected Problems}

\setexernumber{3}

\exer[3.5.4]{}{
    Let \(B = \mcal{P}(A)\). Show that \((B, \cup_B, \cap_B)\) and \((B, \cap_B, \cup_B)\)
    are isomorphic structures.
}
\pf{Proof}{
    Let \(h \colon B \to B\) be defined by \(h(X) = A \setminus X\).
    If \(A \setminus X = A \setminus Y\), then
    \(X = A \setminus (A \setminus X) = A \setminus (A \setminus Y) = Y\)
    by \ref{itm:1.4.2iii}.
    Moreover, \(h(h(X)) = X\) for all \(X \in B\).
    Hence, \(h \colon B \hooktwoheadrightarrow B\). 
}

\setexernumber{6}

\exer[3.5.7]{}{
    Let \(R\) be a set whose elements are \(n\)-tuples.
    Then, \(R\) is an \(n\)-ary relation in \(A\) for some \(A\).
}
\pf{Proof}{
    Let \(a \in R\). Then, \(a = \{(0, a_0), \cdots, (n-1, a_{n-1})\}\).
    For each \(i < n\),
    \(a_i \in \{i, a_i\} \in (i, a_i) \in a \in R\).
    Hence, \(a_i \in \bigcup \left[ \bigcup \left( \bigcup R\right)\right]\),
    i.e., \(R\) is an \(n\)-ary relation in \(A = \bigcup \left[ \bigcup \left( \bigcup R\right)\right]\).
}

\setexernumber{12}

\exer[3.5.13]{}{
    Let \(\lang\,k_0, \cdots, k_{n-1}\,\rang\) be a finite sequence of
    natural numbers of length \(n \ge 1\).
    Then, its range \(\{\,k_0, \cdots, k_{n-1}\,\}\) has a greatest element.
}
\pf{Proof}{
    Let \(\mbf{P}(x)\) be the property
    ``the range of a finite sequence of natural numbers of length \(x\)
    has a greatest element.''
    
    Let \(\lang k_0 \rang\) be a sequence of natural numbers of length \(1\).
    Then, \(k_0 = \max \ran \lang k_0 \rang\).
    Hence, \(\mbf{P}(1)\).

    Fix any \(n \in \NN\) and assume \(\mbf{P}(n)\).
    Take any \(k \in \Seq(\NN)\) with length \(n + 1\).
    Let \(k' = \lang\,k_0, \cdots, k_{n-1}\,\rang\) be another sequence.
    Then, by \(\mbf{P}(n)\), there exists \(m' = \max \{\,k_0, \cdots,k_{n-1}\,\}\).
    Now, let \(m = \max \{\,m', k_{n}\,\}\).
    Then, for all \(i < n\), \(k_i \le m' \le m\),
    and \(k_n \le m\).
    Hence, \(m\) is an upper bound of \(\ran k\);
    the result follows by \Cref{th:hasUpperBoundThenMaxExists} and \Cref{exer:3.2.11}.
}

\setexernumber{14}

\exer[3.4.15]{}{
    Let \(R \subseteq A^2\) be a binary relation. Define a binary operation \(F_R\) on \(A^2\) by
    \[
        F_R((a_1, a_2), (b_1, b_2)) = \begin{cases}
            (a_1, b_2) & \text{if } a_2 = b_1 \\
            \text{undefined} & \text{otherwise}.
        \end{cases}
    \]
    Then,
    \begin{enumerate}[nolistsep, label=(\roman*), leftmargin=*]
        \ii The closure of \(R\) in \((A^2, F_R)\) is a transitive relation.
        \ii If \(R\) is reflexive and symmetric, \(\cl{R}\) is also an equivalence.
    \end{enumerate}
}
\mclm{Proof}{\hfill
\begin{enumerate}[nolistsep, label=(\roman*), leftmargin=*, listparindent=\parindent]
    \ii
    Take any \(a, b, c \in A\) and assume \(a\cl{R}b\) and \(b\cl{R}c\).
    Then, since \(\cl{R}\) is closed, \(F((a, b), (b, c)) = (a, c) \in \cl{R}\).
    Hence, \(\cl{R}\) is transitive.

    \ii
    \(\mrm{Id}_A \subseteq R \subseteq \cl{R}\); \(\cl{R}\) is reflexive.

    Let \(\mbf{P}(x, y)\) be the property ``\(y \cl{R} x\).''
    As \(R \subseteq \cl{R}\), we have \(\fall (a, b) \in R,\: \mbf{P}(a, b)\).
    Now, take any \((a, b), (b, c) \in A^2\) such that \(\mbf{P}(a, b)\) and \(\mbf{P}(b, c)\).
    Then, by (i), we have \(c \cl{R}a\); \(\mbf{P}(F_R((a, b), (b, c)))\) hold.
    Therefore, by \nameref{th:generalInduction},
    \(b\cl{R}a\) holds for all \((a, b) \in \cl{R}\).
    \qed
\end{enumerate}
}

\end{document}
